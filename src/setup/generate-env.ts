#!/usr/bin/env node
/**
 * Generate .env file from configuration
 * Usage: node setup/generate-env.js --output=.env
 */

import * as fs from 'fs';
import * as path from 'path';
import { SetupConfig } from './shared-types.js';
import { log } from './utils.js';

/**
 * Generate .env file content from config
 */
export function generateEnvContent(config: SetupConfig): string {
  const lines: string[] = [
    '# Agent Task Manager - Environment Configuration',
    '# Generated by setup script',
    '',
    '# Linear Configuration',
    `LINEAR_API_KEY=${config.linear.apiKey}`,
    `LINEAR_TEAM_ID=${config.linear.teamId}`,
    '',
  ];

  // Storage backend
  const backend = config.storageBackend || 'basic-memory';
  lines.push('# Storage Backend');
  lines.push(`STORAGE_BACKEND=${backend}`);
  lines.push('');

  if (backend === 'basic-memory' && config.basicMemory) {
    // Basic-memory configuration
    lines.push('# Basic Memory Configuration');
    lines.push(`BASIC_MEMORY_ROOT_PATH=${config.basicMemory.rootPath}`);
    lines.push(`BASIC_MEMORY_GLOBAL_PATH=${config.basicMemory.globalPath}`);
    lines.push('');

    // Project mappings for basic-memory
    if (config.projects.length > 0) {
      lines.push('# Project Mappings (optional - see auto-discovery below)');
      lines.push('# Format: {"project-name": {"linearProjectId": "uuid", "path": "./path"}}');

      const mappings: Record<string, { linearProjectId: string; path: string }> = {};
      config.projects.forEach((project) => {
        if (project.path) {
          mappings[project.name] = {
            linearProjectId: project.linearProjectId,
            path: project.path,
          };
        }
      });

      lines.push(`PROJECT_MAPPINGS=${JSON.stringify(mappings)}`);
    } else {
      lines.push('# Project Mappings (using auto-discovery)');
      lines.push('# Projects are automatically discovered from Linear on first use.');
      lines.push('# Storage path: {BASIC_MEMORY_ROOT_PATH}/projects/{sanitized-project-name}');
      lines.push('# To pre-configure projects manually, add PROJECT_MAPPINGS here.');
      lines.push('# PROJECT_MAPPINGS={}');
    }
  } else if (backend === 'notion' && config.notion) {
    // Notion configuration
    lines.push('# Notion Configuration');
    lines.push(`NOTION_API_KEY=${config.notion.apiKey}`);

    // Global databases (optional)
    if (config.notion.globalLessonsDbId || config.notion.globalDecisionsDbId) {
      lines.push('');
      lines.push('# Global Databases (optional)');
      if (config.notion.globalLessonsDbId) {
        lines.push(`NOTION_GLOBAL_LESSONS_DB_ID=${config.notion.globalLessonsDbId}`);
        if (config.notion.globalLessonsDataSourceId) {
          lines.push(`NOTION_GLOBAL_LESSONS_DATA_SOURCE_ID=${config.notion.globalLessonsDataSourceId}`);
        }
      }
      if (config.notion.globalDecisionsDbId) {
        lines.push(`NOTION_GLOBAL_DECISIONS_DB_ID=${config.notion.globalDecisionsDbId}`);
        if (config.notion.globalDecisionsDataSourceId) {
          lines.push(`NOTION_GLOBAL_DECISIONS_DATA_SOURCE_ID=${config.notion.globalDecisionsDataSourceId}`);
        }
      }
    }

    // Project mappings for notion
    if (config.projects.length > 0) {
      lines.push('');
      lines.push('# Project Mappings');
      lines.push('# Format: {"project-name": {"linearProjectId": "uuid", "notionLessonsDbId": "uuid", "notionLessonsDataSourceId": "uuid", "notionDecisionsDbId": "uuid", "notionDecisionsDataSourceId": "uuid"}}');

      const mappings: Record<
        string,
        {
          linearProjectId: string;
          notionLessonsDbId: string;
          notionLessonsDataSourceId: string;
          notionDecisionsDbId: string;
          notionDecisionsDataSourceId: string;
        }
      > = {};
      config.projects.forEach((project) => {
        if (
          project.notionLessonsDbId &&
          project.notionDecisionsDbId &&
          project.notionLessonsDataSourceId &&
          project.notionDecisionsDataSourceId
        ) {
          mappings[project.name] = {
            linearProjectId: project.linearProjectId,
            notionLessonsDbId: project.notionLessonsDbId,
            notionLessonsDataSourceId: project.notionLessonsDataSourceId,
            notionDecisionsDbId: project.notionDecisionsDbId,
            notionDecisionsDataSourceId: project.notionDecisionsDataSourceId,
          };
        }
      });

      lines.push(`PROJECT_MAPPINGS=${JSON.stringify(mappings)}`);
    }
  }

  // Uncertainty mode (optional)
  if (config.uncertaintyMode) {
    lines.push('');
    lines.push('# Uncertainty Resolution Mode');
    lines.push('# Options: off (allow), warn (log warning), block (prevent decomposition)');
    lines.push(`UNCERTAINTY_RESOLUTION_MODE=${config.uncertaintyMode}`);
  }

  lines.push('');
  return lines.join('\n');
}

/**
 * Write .env file
 */
export function writeEnvFile(
  config: SetupConfig,
  outputPath: string = '.env',
  options: { force?: boolean; backup?: boolean } = {}
): void {
  const { force = false, backup = true } = options;

  const fullPath = path.resolve(outputPath);
  const content = generateEnvContent(config);

  // Check if file exists
  if (fs.existsSync(fullPath) && !force) {
    throw new Error(
      `.env file already exists at ${fullPath}. Use --force to overwrite or --backup to create backup.`
    );
  }

  // Create backup if requested
  if (fs.existsSync(fullPath) && backup) {
    const backupPath = `${fullPath}.backup.${Date.now()}`;
    fs.copyFileSync(fullPath, backupPath);
    log.info(`Created backup: ${backupPath}`);
  }

  // Write file
  fs.writeFileSync(fullPath, content, 'utf-8');
  log.success(`Generated .env file: ${fullPath}`);
}

/**
 * Generate template .env file
 */
export function generateEnvTemplate(): string {
  return `# Agent Task Manager - Environment Configuration

# Linear Configuration
LINEAR_API_KEY=lin_api_YOUR_KEY_HERE
LINEAR_TEAM_ID=YOUR_TEAM_ID

# Notion Configuration
NOTION_API_KEY=YOUR_INTEGRATION_TOKEN_HERE

# Project Mappings
# Format: {"project-name": {"linearProjectId": "uuid", "notionLessonsDbId": "uuid", "notionDecisionsDbId": "uuid"}}
PROJECT_MAPPINGS={"my-project":{"linearProjectId":"PROJECT_ID","notionLessonsDbId":"DB_ID","notionDecisionsDbId":"DB_ID"}}

# Global Databases (optional)
# NOTION_GLOBAL_LESSONS_DB_ID=YOUR_DB_ID
# NOTION_GLOBAL_DECISIONS_DB_ID=YOUR_DB_ID

# Uncertainty Resolution Mode (optional)
# Options: off (allow decomposition with unresolved uncertainties)
#          warn (allow but log warning - default)
#          block (prevent decomposition until resolved)
# UNCERTAINTY_RESOLUTION_MODE=warn
`;
}

/**
 * CLI mode
 */
if (import.meta.url === `file://${process.argv[1]}`) {
  const args = process.argv.slice(2);
  const templateMode = args.includes('--template');
  const outputPath = args.find((arg) => arg.startsWith('--output='))?.split('=')[1] || '.env';

  if (templateMode) {
    // Generate template
    const templateContent = generateEnvTemplate();
    const templatePath = path.resolve(outputPath);

    fs.writeFileSync(templatePath, templateContent, 'utf-8');
    log.success(`Generated .env template: ${templatePath}`);
    log.info('Fill in the values and save as .env');
    process.exit(0);
  }

  // Interactive mode - read from stdin or config file
  console.error('Usage:');
  console.error('  Generate template:');
  console.error('    node generate-env.js --template [--output=.env.template]');
  console.error('  Generate from config:');
  console.error('    node generate-env.js --config=config.json [--output=.env] [--force]');
  process.exit(1);
}
